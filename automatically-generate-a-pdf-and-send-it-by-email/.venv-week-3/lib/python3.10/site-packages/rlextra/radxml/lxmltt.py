__all__ =   (
            'LxmlTT',
            )
from lxml import etree as ET
import chardet
import sys, io

class LxmlTT:
    _parser_defaults = dict(
                            attribute_defaults = False,
                            dtd_validation = False,
                            load_dtd = False,
                            no_network = True,
                            ns_clean = True,
                            recover = False,
                            remove_blank_text = False,
                            remove_comments = True,
                            remove_pis = True,
                            strip_cdata = True,
                            resolve_entities = True,
                            huge_tree = False,
                            compact = True, 
                            collect_ids = False,
                            )
    def __init__(self, resolver=None, textCnvt=None, returnUTF8=False, fourth=False, empty_ret=lambda:None, **kwds):
        pkw = {k:kwds.pop(k,v) for k,v in self._parser_defaults.items()}
        self.parser = ET.XMLParser(**pkw)
        self.returnUTF8 = returnUTF8
        self.resolve_entities = pkw['resolve_entities']
        self.fourth = (
                fourth if callable(fourth) 
                else (lambda e: None) if not fourth 
                else (lambda e:e.sourceline)
                )
        self.empty_ret = empty_ret
        if resolver:
            self.parser.resolvers.add(resolver())

        if returnUTF8:
            self.textCnvt = (lambda s: textCnvt(s).encode('utf8')) if textCnvt else (lambda s: s.encode('utf8'))
        else:
            self.textCnvt = lambda _:_

    def ttFromFile(self,f):
        if self.resolve_entities:
            tree = ET.parse(f,self.parser)
        else:
            if hasattr(f,'read'):
                s = f.read()
            else:
                with open(f,'rb') as _:
                    s = _.read()
            if isinstance(s,bytes):
                cdd = chardet.detect(s)
                enc = cdd['encoding']
                s = s.replace('&'.encode(enc),'&amp;'.encode(enc))
            else:
                s = s.replace('&','&amp;')
            tree = ET.fromstring(s,self.parser)
        if tree is not None: return self.maketuple(next(tree.iter()))

    def ttFromSrc(self, s, encoding=None):
        return self.ttFromFile((io.BytesIO if isinstance(s,bytes) else io.StringIO)(s))

    def maketuple(self,e):
        tag = e.tag
        attrib = e.attrib
        if self.returnUTF8:
            tag = tag.encode('utf8')
            if attrib:
                attrib = {k.encode('utf8'):v.encode('utf8') for k,v in attrib.items()}
        elif attrib:
            attrib = {k:v for k,v in attrib.items()}
        e4 = self.fourth(e)
        return (tag,attrib or None,self.content(e), e4)

    def content(self, e):
        t = e.text
        kids = e.getchildren()
        if len(kids)==0 and t is None:
            return self.empty_ret()
        else:
            r = [].append
            func = self.textCnvt
            if t is not None: r(func(t))
            for c in kids:
                r(self.maketuple(c))
                t = c.tail
                if t is not None:
                    r(func(t))
            return r.__self__


if __name__=='__main__':
    from pprint import pprint
    xml = '<a attr0="&#33;">AAAAA &#33; &lt; &amp; &gt;<b attr1="&#33;">BBBBB &#33; &lt; &amp; &gt;</b></a>'
    xmlb = b'<a attr0="&#33;">AAAAA &#33; &lt; &amp; &gt;<b attr1="&#33;">BBBBB &#33; &lt; &amp; &gt;</b></a>'
    if len(sys.argv)>=1:
        import re, os
        from rlextra.rml2pdf import rml2pdf
        rmlDTDPat = re.compile('^.*(?:\\W|\\b)(?P<fn>%s)$' % '|'.join((re.escape(_) for _ in rml2pdf.CompatibleDTDNames)),re.M)
        class RMLDTDResolver(ET.Resolver):
            __dtds = {}
            def resolve(self, url, eid, context):
                m = rmlDTDPat.match(url)
                if m:
                    for fn in ('rml.dtd','dynamic_rml.dtd'):
                        with open(os.path.join(os.path.dirname(rml2pdf.__file__),fn),'rb') as _:
                            self.__dtds[fn] = _.read()
                    fn = m.group('fn')
                    dtdPath = 'rml.dtd' if fn.startswith('rml') else 'dynamic.dtd'
                    #print(f"Resolving url={url!r} context={context!r} {dtdPath=}")
                    return self.resolve_string(
                            self.__dtds[dtdPath],
                            context,
                            )

        parser = LxmlTT(resolver=RMLDTDResolver)
        for fn in sys.argv[1:]:
            pprint(parser.ttFromFile(fn))
            with open(fn,'rb') as _:
                b = _.read()
                pprint(parser.ttFromSrc(b))
    parser = LxmlTT()
    print(repr(parser.ttFromSrc(xml)))
    parser = LxmlTT(returnUTF8=1)
    print(repr(parser.ttFromSrc(xml)))
    parser = LxmlTT(returnUTF8=1,resolve_entities=0)
    print(repr(parser.ttFromSrc(xml)))
    parser = LxmlTT(resolve_entities=0)
    print(repr(parser.ttFromSrc(xml)))
    print(repr(parser.ttFromSrc(xmlb)))
    parser = LxmlTT(returnUTF8=1)
    print(repr(parser.ttFromSrc(xmlb)))
    parser = LxmlTT(returnUTF8=1,resolve_entities=0)
    print(repr(parser.ttFromSrc(xmlb)))
    parser = LxmlTT(resolve_entities=False)
    print(repr(parser.ttFromSrc(xmlb)))
