__all__ = ()    #everything should be expolicitly imported
class RmlDebug(object):
    '''
    Horrible hacky code to debug rml2pdf; when setup_debug is called it looks at
    the globals dict it is given and messes with a bunch of klasses to get them
    to annotate their instances with suitable information from the parse.

    At the end of setup_debug the sys exception hook is overridden and the old one
    returned so the class can store it.

    When called without a dict the cleanup action is performed if needed.
    '''
    @classmethod
    def __setup_debug(cls,G):
        Controller = G['Controller']
        MapController = G['MapController']
        Flowable = G['Flowable']
        xml2TT = G['xml2TT']
        xmlParser = xml2TT.xmlParser
        xml2Attrs = xml2TT.xml2Attrs
        DeferredInitialization = G['DeferredInitialization']
        import sys, inspect, re
        from reportlab.lib.utils import flatten
        from reportlab.lib.rl_accel import fp_str
        from reportlab.platypus.tables import Table
        from functools import wraps
        xmlInputText = G['xmlInputText']
        isclass = inspect.isclass
        hacked_klasses = {}
        _oldLocMap = {}
        if xmlParser=='lxml':
            def ttag2StartLine(ttag):
                return ttag[3][1].sourceline
            def getParsed():
                return G['parsed']
            oldLocMap = lambda _: _
        else:
            def mkseq(t,N=[-1]):
                N[0]+=1
                return t+(N[0],)
            class RelocatedTTTuple(tuple):
                pass
            def ttrecur(tt,seq=()):
                if not isinstance(tt,tuple): return tt
                tag, attrs, content, loc = tt
                seq = mkseq(seq)
                if content is not None:
                    content = [ttrecur(c,seq) for c in content]
                newLoc = (seq,loc[0][1]+1)
                _oldLocMap[loc] = newLoc
                return RelocatedTTTuple((tag,attrs,content,newLoc))
            def ttag2StartLine(ttag):
                loc = ttag[3]
                return loc[1] if isinstance(ttag,RelocatedTTTuple) else loc[0][1]+1
            def getParsed():
                if '__parsed_relocated__' not in G:
                    G['__parsed_relocated__'] = ttrecur(G['parsed'])
                return G['__parsed_relocated__']
            oldLocMap = lambda _: _oldLocMap[_] if _ in _oldLocMap else _

        def get_nodemappers(L):
            aL = L.append
            for v in Controller.nodemappers.values():
                v = getattr(v,'__class__',None)
                if v and isclass(v):
                    aL(v)
            return L

        class TagAndObj(tuple): #tag with a name
            def __new__(cls, v, obj):
                t = tuple.__new__(cls,v)
                t.__obj = obj
                return t
            @property
            def obj(self):
                return self.__obj
            @property
            def name(self):
                obj = self.__obj
                try:
                    return obj.__name__
                except AttributeError:
                    try:
                        return obj.__class__.__name__
                    except:
                        return ''

        def get_klasses(L, target_klasses = Flowable):
            aL = L.append
            for v in G.values():
                if isclass(v) and issubclass(v, target_klasses):
                    aL(v)
            return L

        def make_init(klass):
            def __init__(self,*args,**kwds):
                init_annotation(self)
                klass.__rml2pdf_old_init__(self,*args,**kwds)
            return __init__

        class FuncWrap:
            '''make a callable from a function; instances can be annotated'''
            def __init__(self, func):
                self.func = func
            def __call__(self, *args, **kwds):
                return self.func(*args,**kwds)

        def best_tag(tag,tagr):
            if tagr is None:
                tagr = tag
            else:
                t = tag[3][0]
                tr = tagr[3][0]
                if len(t)>len(tr) or t>tr: tagr = tag
            return tagr

        def set_best_tag(tag, r, func=False):
            if hasattr(r,'__dict__') and (r.__class__.__name__ in hacked_klasses or func):
                r.__dict__['__rml2pdf_tag_annotation__'] = best_tag(tag, r.__dict__.get('__rml2pdf_tag_annotation__',None))
            else:
                if isinstance(r,list):
                    for r1 in r:
                        set_best_tag(tag,r1)
                #elif callable(r):
                #   r = FuncWrap(r)
                #   r.__dict__['__rml2pdf_tag_annotation__'] = tag
            return r

        def whereFromSeq(v):
            if v:
                v = flatten(v)
                tag0 = next((_ for _ in v if hasattr(_,'__rml2pdf_tag_annotation__')),None)
                if not tag0: return
                return tag0.__rml2pdf_tag_annotation__
                if len(v)==1:
                    return tag0
                else:
                    tagn = next((_ for _ in reversed(v) if hasattr(_,'__rml2pdf_tag_annotation__')),None)
                    if not tagn: return tag0
                    tagn = tagn.__rml2pdf_tag_annotation__[3]
                    if tagn is tag0: return tag0
                    t0 = (tag0[1] or tag0[2]) if tag0 else None
                    tn = (tagn[2] or tagn[1]) if tagn else None
                    return (tag0[0],t0,tn)

        def make_initialize(klass):
            def initialize(self,*args,**kwds):
                r = klass.__rml2pdf_old_initialize__(self,*args,**kwds)
                tag = self.__dict__.get('__rml2pdf_tag_annotation__',None)
                if tag:
                    set_best_tag(tag,r)
                else:
                    init_annotation(r)
                return r
            return initialize

        def make_evaluate(klass):
            def evaluate(self, tagname, sdict, pcontent, extra, context, *args, **kwds):
                r = klass.__rml2pdf_old_evaluate__(self, tagname, sdict, pcontent, extra, context, *args,**kwds)

                return set_best_tag((tagname, sdict, None, extra),r,True)
            return evaluate

        def make_processTuple(klass):
            def processTuple(self, e, *args, **kwds):
                self.__rml2pdf_tuple_stack__.append(e)
                r = klass.__rml2pdf_old_processTuple__(self, e, *args,**kwds)
                self.__rml2pdf_tuple_stack__.pop()
                return r
            return processTuple

        def make_tableSplit(klass):
            def split(self, *args, **kwds):
                r = klass.__rml2pdf_old_split__(self, *args,**kwds)
                if r:
                    T0, T1 = r
                    T1.__rml_initial_row__ = T0._nrows+getattr(T0,'__rml_initial_row__',0)
                return r
            return split

        def find_annotation(F, deep=False):
            if MapController.__rml2pdf_tuple_stack__:
                return MapController.__rml2pdf_tuple_stack__[-1]
            tag = None
            for frame, fn, lnum, func, lines, index in F:
                f_locals = frame.f_locals
                self = f_locals.get('self', None)
                if self is not None:
                    tag1 = self.__dict__.get('__rml2pdf_tag_annotation__',None)
                    if tag1:
                        tag1 = TagAndObj(tag1,self)
                        tag = best_tag(tag1,tag)
                    if 'rml2pdf' in fn and self.__class__.__name__=='CanvasOps':
                        obj = f_locals.get('op',None)
                        if obj  is not None and hasattr(obj,'__dict__'):
                            tag1 = obj.__dict__.get('__rml2pdf_tag_annotation__',None)
                            if tag1:
                                tag1 = TagAndObj(tag1,obj)
                                tag = best_tag(tag1,tag)

                if 'doctemplate' in fn and func=='handle_flowable':
                    obj = f_locals.get('f',None)
                    if obj is not None:
                        tag1 = obj.__dict__.get('__rml2pdf_tag_annotation__',None)
                        if tag1:
                            tag1 = TagAndObj(tag1,obj)
                            tag = best_tag(tag1,tag)
                if tag and not deep: return tag
            return tag

        def init_annotation(self):
            tag = find_annotation(inspect.stack(1))
            if tag: set_best_tag(tag,self)

        def find_nth(s, p, n):
            i = s.find(p)
            while i >= 0 and n > 1:
                i = s.find(p, i+len(p))
                n -= 1
            return i

        class TTagLocator:
            def findTag(self, ttag):
                tag = ttag[0]
                start_line = ttag2StartLine(ttag)
                possibles = []
                ttstack = [getParsed()]
                while ttstack:
                    tt = ttstack.pop()
                    if tt[0]==tag and ttag2StartLine(tt)==start_line:
                        possibles.append(oldLocMap(tt[3]))
                    if tt[2]:
                        for child in tt[2]:
                            if isinstance(child,tuple):
                                ttstack.append(child)
                possibles = list(sorted(possibles))
                where = oldLocMap(ttag[3])
                n = possibles.index(where) if where in possibles else 0
                i = find_nth(xmlInputText,b'\n',start_line-1)+1
                tmp = xmlInputText[i:]
                stag = tag.encode('utf8')
                st = b'<%s' % stag
                pat = b'%s\\b' % st
                m = list(re.finditer(pat,tmp,re.M))
                if m:
                    m = m[n]
                    if m:
                        j = m.start()
                        tmp = tmp[j:]
                else:
                    k = i
                    while k>=0:
                        j = xmlInputText.rfind(st,0,k)
                        if j<0: break
                        m = re.match(pat,xmlInputText[j:])
                        if m: break
                        k = j-1
                    if m:
                        start_line = xmlInputText.count(b'\n',0,j)+1
                        i = find_nth(xmlInputText,b'\n',start_line-1)+1
                        tmp = xmlInputText[i:]
                        j = j - i
                        tmp = tmp[j:]
                if not m:
                    j = '???'
                    self.tagStart = None
                else:
                    j += 1
                    self.tagStart = tmp[:tmp.find(b'>')+1]
                self.start = (start_line,j)
                lim = 10*len(tmp)
                k0 = tmp.find(b'/>')
                k1 = tmp.find(b'</%s' % stag)
                if k0>=0 and tmp.rfind(b'<',0,k0)==0:
                    k0 += 1
                else:
                    k0 = lim
                if k1>=0:
                    k = tmp.find(b'>',k1)
                    if k>=0:
                        k1 = k + 1
                    else:
                        k1 += 2 + len(stag)
                else:
                    k1 = lim
                k = min(k1,k0)
                if k==lim:
                    self.end = ('???','???')
                else:
                    tmp = tmp[:k]
                    k0 = start_line + tmp.count(b'\n')
                    k1 = len(tmp) - tmp.rfind(b'\n')
                    if k0==start_line: k1 += j
                    self.end = k0, k1 - 1
                self.tmp = tmp
                return self.start + self.end

        def whereFormat(ttag,getAttrs=False):
            if ttag:
                ttl = TTagLocator()
                start_line, start_offs, end_line, end_offs = ttl.findTag(ttag)
                where = f' @ {start_line}:{start_offs} - {end_line}:{end_offs}'
                xml = ttl.tagStart
                if xml:
                    if not xml.endswith(b'/>'):
                        xml = xml[:-1] + b'/>'
                    try:
                        attrs = xml2Attrs(xml)
                        attrs = dict(attrs.items()) if attrs else None
                    except:
                        attrs = None
                return (where,attrs) if getAttrs else where
            else:
                return ''

        def tag_format(ttag):
            tag, attrs, content, where = ttag
            wFmt, oattrs = whereFormat(ttag,True)
            if oattrs is not None:
                attrs = oattrs
            b = '\n!!!!! ' + (len(tag)+2)*'\x20'
            if attrs:
                attrs = b + b.join(('%s=%r' % (k,v) for k,v in sorted(attrs.items())))
            else:
                attrs = ''
            haveObj = isinstance(ttag,TagAndObj)
            objName = ttag.name if haveObj else ''
            if objName: objName = ' (%s)' % objName
            xtra = [].append
            if haveObj:
                if isinstance(ttag.obj,Table):
                    irow = getattr(ttag.obj,'__rml_initial_row__',0)
                    rowH = [(h,i) for i,h in enumerate(ttag.obj._rowHeights) if h is not None and h>0]
                    rowH.sort(reverse=True)
                    if rowH:
                        xtra(b+'largest row heights = [%s]'
                                % ', '.join(('|%d|=%s%s' % (irow+i+1,fp_str(h),whereFormat(whereFromSeq(ttag.obj._cellvalues[i]))) for h,i in rowH[:5])))
            xtra = xtra.__self__
            xtra = '\n'.join(xtra) if xtra else ''
            return '\n!!!!! <%s%s>%s%s%s' % (tag, attrs, objName, wFmt, xtra)

        def hacked_methods():
            for m in (
                    #saved name, original name
                    ('__rml2pdf_old_init__','__init__'),
                    ('__rml2pdf_old_initialize__','initialize'),
                    ('__rml2pdf_old_evaluate__','evaluate'),
                    ):
                yield m

        def cleanup():
            if cls.__oldhook:
                sys.excepthook = cls.__oldhook
            cls.__cleanup = cls.__oldhook = None
            def restore_klass(klass,meth,smeth):
                if smeth in klass.__dict__:
                    setattr(klass,meth,klass.__dict__[smeth])
                    delattr(klass,smeth)
            restore_klass(MapController,'processTuple','__rml2pdf_old_processTuple__')
            if '__rml2pdf_tuple_stack__' in MapController.__dict__: del MapController.__rml2pdf_tuple_stack__
            restore_klass(Table,'split','__rml2pdf_old_split__')
            for name, klass in hacked_klasses.items():
                for smeth, meth in hacked_methods():
                    restore_klass(klass,meth,smeth)
            hacked_klasses.clear()
            G.clear()
            _oldLocMap.clear()

        def process_exception(t,v,s):
            cls.__oldhook(t,v,s)    #perform original behaviour
            tag = find_annotation(tuple(reversed(inspect.getinnerframes(s, 1))), deep=True)
            if tag:
                sys.stderr.write('!!!!! tag leading to the problem was%s\n' % tag_format(tag))
            cleanup()

        for v in get_nodemappers(
                        get_klasses([],
                            target_klasses=(Flowable,DeferredInitialization))):
            k = v.__name__
            if k in hacked_klasses: continue
            for smeth, meth in hacked_methods():
                if meth in v.__dict__ and smeth not in v.__dict__:
                    setattr(v,smeth,v.__dict__[meth])
                    setattr(v,meth,locals()['make_%s'%meth.replace('_','')](v))
            hacked_klasses[k] = v
            
        MapController.__rml2pdf_tuple_stack__ = []
        MapController.__rml2pdf_old_processTuple__ = MapController.processTuple
        MapController.processTuple = make_processTuple(MapController)
        Table.__rml2pdf_old_split__ = Table.split
        Table.split = make_tableSplit(Table)
        cls.__cleanup = cleanup
        cls.__oldhook = sys.excepthook
        sys.excepthook = process_exception

    __cleanup = __oldhook = None

    @classmethod
    def __call__(cls,G):
        if G and not cls.__cleanup:
            cls.__setup_debug(G)
        elif cls.__cleanup:
            cls.__cleanup()


RmlDebug = RmlDebug()
